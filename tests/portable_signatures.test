#!/bin/bash

#
# Check if operations on files with EVM portable signatures succeed.

trap cleanup SIGINT SIGTERM EXIT

# Base VERBOSE on the environment variable, if set.
VERBOSE="${VERBOSE:-0}"
TST_EVM_CHANGE_MODE="${TST_EVM_CHANGE_MODE:-0}"

# From security/integrity/evm/evm.h in kernel source directory
let "EVM_INIT_HMAC=0x0001"
let "EVM_INIT_X509=0x0002"
let "EVM_ALLOW_METADATA_WRITES=0x0004"

cd "$(dirname "$0")"
export PATH=../src:$PATH
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH
. ./functions.sh
_require evmctl

cleanup() {
	if [ "$loop_mounted" = "1" ]; then
		popd > /dev/null
		umount /mnt
	fi

	if [ -n "$dev" ]; then
		losetup -d $dev
	fi

	rm -f test.img
	rm -f signing_key.der
	_report_exit
}

get_xattr() {
	getfattr -n $1 -e hex -d $2 | awk -F "=" '$1 == "'$1'" {v=substr($2, 3); print v}'
}

IMA_UUID="28b23254-9467-44c0-b6ba-34b12e85a26d"
APPRAISE_DIGSIG_FOWNER=2000
APPRAISE_DIGSIG_RULE="appraise fsuuid=$IMA_UUID fowner=$APPRAISE_DIGSIG_FOWNER appraise_type=imasig"
MEASURE_FOWNER=2001
MEASURE_RULE="measure fsuuid=$IMA_UUID fowner=$MEASURE_FOWNER template=ima-sig"
APPRAISE_FOWNER=2002
APPRAISE_RULE="appraise fsuuid=$IMA_UUID fowner=$APPRAISE_FOWNER"

check_load_ima_rule() {
	rule_loaded=$(cat /sys/kernel/security/ima/policy | grep "$1")
	if [ -z "$rule_loaded" ]; then
		echo $1 > /sys/kernel/security/ima/policy
		if [ $? -ne 0 ]; then
			echo "${RED}Failed to set IMA policy${NORM}"
			return $FAIL
		fi
	fi

	return $OK
}

check_ima_sig_appraisal() {
	echo "Test: ${FUNCNAME[0]}"

	if [ $evm_value -ne 0 ]; then
		echo "${CYAN}EVM mode 0 required${NORM}"
		return $SKIP
	fi

	echo "test" > test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot write test-file${NORM}"
		return $FAIL
	fi

	evmctl ima_sign -a sha256 --key $key_path test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot sign test-file${NORM}"
		return $FAIL
	fi

	chown $APPRAISE_DIGSIG_FOWNER test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot change owner of test-file${NORM}"
		return $FAIL
	fi

	check_load_ima_rule "$APPRAISE_DIGSIG_RULE"
	result=$?
	if [ $result -ne $OK ]; then
		return $result
	fi

	# Check if appraisal works.
	cat test-file > /dev/null
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot read test-file${NORM}"
		return $FAIL
	fi

	# Ensure that files with IMA signature cannot be updated (immutable).
	echo "test" 2> /dev/null >> test-file
	if [ $? -eq 0 ]; then
		echo "${RED}Write to test-file should not succeed (immutable file)${NORM}"
		return $FAIL
	fi

	return $OK
}

cleanup_ima_sig_appraisal() {
	rm -f test-file
}

check_ima_sig_ima_measurement_list() {
	echo "Test: ${FUNCNAME[0]}"

	if [ $evm_value -ne 0 ]; then
		echo "${CYAN}EVM mode 0 required${NORM}"
		return $SKIP
	fi

	echo "test" > test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot write test-file${NORM}"
		return $FAIL
	fi

	evmctl ima_sign -a sha256 --imasig --key $key_path test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot sign test-file${NORM}"
		return $FAIL
	fi

	chown $MEASURE_FOWNER test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot change owner of test-file${NORM}"
		return $FAIL
	fi

	check_load_ima_rule "$MEASURE_RULE"
	result=$?
	if [ $result -ne $OK ]; then
		return $result
	fi

	# Read the file to add it to the measurement list.
	cat test-file > /dev/null
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot read test-file${NORM}"
		return $FAIL
	fi

	ima_sig_fs=$(get_xattr security.ima test-file)
	if [ -z "$ima_sig_fs" ]; then
		echo "${RED}security.ima not found${NORM}"
		return $FAIL
	fi

	# Search security.ima in the measurement list.
	ima_sig_list=$(cat /sys/kernel/security/ima/ascii_runtime_measurements | awk '$6 == "'$ima_sig_fs'"')
	if [ -z "$ima_sig_list" ]; then
		echo "${RED}security.ima mismatch (xattr != measurement list)${NORM}"
		return $FAIL
	fi

	return $OK
}

cleanup_ima_sig_ima_measurement_list() {
	rm -f test-file
}

# Requires:
# - evm: Execute evm_inode_init_security() only when an HMAC key is loaded
check_create_file() {
	echo "Test: ${FUNCNAME[0]}"

	# To trigger the bug we need to enable public key verification without HMAC key loaded.
	if [ $((evm_value & $EVM_INIT_X509)) -ne $EVM_INIT_X509 ]; then
		echo "${CYAN}EVM mode $EVM_INIT_X509 required${NORM}"
		return $SKIP
	fi

	if [ $((evm_value & $EVM_INIT_HMAC)) -eq $EVM_INIT_HMAC ]; then
		echo "${CYAN}EVM mode $EVM_INIT_HMAC must be disabled${NORM}"
		return $SKIP
	fi

	echo "test" > test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot write test-file${NORM}"
		return $FAIL
	fi

	return $OK
}

cleanup_create_file() {
	rm -f test-file
}

# Requires:
# - evm: Ignore INTEGRITY_NOLABEL if no HMAC key is loaded
# - evm: Allow xattr/attr operations for portable signatures
# - evm: Execute evm_inode_init_security() only when an HMAC key is loaded
check_cp_preserve_xattrs() {
	echo "Test: ${FUNCNAME[0]}"

	if [ $evm_value -ne $EVM_INIT_X509 ]; then
		echo "${CYAN}EVM mode $EVM_INIT_X509 required${NORM}"
		return $SKIP
	fi

	echo "test" > test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot write test-file${NORM}"
		return $FAIL
	fi

	evmctl sign -o -a sha256 --imahash --key $key_path test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot sign test-file${NORM}"
		return $FAIL
	fi

	# Check if cp is allowed to set metadata for the new file.
	cp -a test-file test-file.copy
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot copy test-file with attrs/xattrs preserved${NORM}"
		return $FAIL
	fi

	return $OK
}

cleanup_cp_preserve_xattrs() {
	rm -f test-file test-file.copy
}

# Requires:
# - evm: Ignore INTEGRITY_NOLABEL if no HMAC key is loaded
# - evm: Allow xattr/attr operations for portable signatures
# - evm: Execute evm_inode_init_security() only when an HMAC key is loaded
# - ima: Don't remove security.ima if file must not be appraised
check_tar_extract_xattrs_different_owner() {
	echo "Test: ${FUNCNAME[0]}"

	if [ $evm_value -ne $EVM_INIT_X509 ]; then
		echo "${CYAN}EVM mode $EVM_INIT_X509 required${NORM}"
		return $SKIP
	fi

	mkdir in out
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot create directories${NORM}"
		return $FAIL
	fi

	echo "test" > in/test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot write test-file${NORM}"
		return $FAIL
	fi

	chown 3000 in/test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot change owner of test-file${NORM}"
		return $FAIL
	fi

	chmod 600 in/test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot change mode of test-file${NORM}"
		return $FAIL
	fi

	evmctl sign -o -a sha256 --imahash --key $key_path in/test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot sign test-file${NORM}"
		return $FAIL
	fi

	tar --xattrs-include=* -cf test-archive.tar in/test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot create archive with xattrs${NORM}"
		return $FAIL
	fi

	# Check if tar is allowed to set metadata for the extracted file.
	# Ensure that the owner from the archive is different from the
	# owner of the extracted file to avoid that portable signature
	# verification succeeds before restoring original metadata
	# (a patch allows modification of immutable metadata if portable
	# signature verification fails).
	tar --xattrs-include=* -xf test-archive.tar -C out
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot extract archive with xattrs${NORM}"
		return $FAIL
	fi

	return $OK
}

cleanup_tar_extract_xattrs_different_owner() {
	rm -Rf in out test-archive.tar
}

# Requires:
# - evm: Ignore INTEGRITY_NOLABEL if no HMAC key is loaded
# - evm: Allow xattr/attr operations for portable signatures
# - evm: Allow setxattr() and setattr() for unmodified metadata
# - evm: Execute evm_inode_init_security() only when an HMAC key is loaded
# - ima: Don't remove security.ima if file must not be appraised
check_tar_extract_xattrs_same_owner() {
	echo "Test: ${FUNCNAME[0]}"

	if [ $evm_value -ne $EVM_INIT_X509 ]; then
		echo "${CYAN}EVM mode $EVM_INIT_X509 required${NORM}"
		return $SKIP
	fi

	mkdir in out
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot create directories${NORM}"
		return $FAIL
	fi

	echo "test" > in/test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot write test-file${NORM}"
		return $FAIL
	fi

	evmctl sign -o -a sha256 --imahash --key $key_path in/test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot sign test-file${NORM}"
		return $FAIL
	fi

	tar --xattrs-include=* -cf test-archive.tar in/test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot create archive with xattrs${NORM}"
		return $FAIL
	fi

	# Check if tar is allowed to set metadata for the extracted file.
	# This test is different from the previous one, as the owner
	# from the archive is the same of the owner of the extracted
	# file. tar will attempt anyway to restore the original owner but
	# unlike the previous test, portable signature verification already
	# succeeds at the time the owner is set (another patch allows
	# metadata operations if those operations don't modify current
	# values).
	tar --xattrs-include=* -xf test-archive.tar -C out
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot extract archive with xattrs${NORM}"
		return $FAIL
	fi

	return $OK
}

cleanup_tar_extract_xattrs_same_owner() {
	rm -Rf in out test-archive.tar
}

# Requires:
# - evm: Ignore INTEGRITY_NOLABEL if no HMAC key is loaded
# - evm: Allow xattr/attr operations for portable signatures
# - evm: Allow setxattr() and setattr() for unmodified metadata
# - ima: Don't remove security.ima if file must not be appraised
# - evm: Execute evm_inode_init_security() only when an HMAC key is loaded
check_metadata_change() {
	echo "Test: ${FUNCNAME[0]}"

	if [ $evm_value -ne $EVM_INIT_X509 ]; then
		echo "${CYAN}EVM mode $EVM_INIT_X509 required${NORM}"
		return $SKIP
	fi

	echo "test" > test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot write test-file${NORM}"
		return $FAIL
	fi

	chown 3001 test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot change owner of test-file${NORM}"
		return $FAIL
	fi

	chmod 600 test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot change mode of test-file${NORM}"
		return $FAIL
	fi

	evmctl sign -o -a sha256 --imahash --key $key_path test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot sign test-file${NORM}"
		return $FAIL
	fi

	# If metadata modification is not allowed, EVM should deny any
	# operation that modifies metadata. Check if setting the same
	# value is allowed.
	chown 3001 test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot set same owner for test-file${NORM}"
		return $FAIL
	fi

	# Setting a different value should not be allowed.
	chown 3002 test-file 2> /dev/null
	if [ $? -eq 0 ]; then
		echo "${RED}Owner change for test-file should not be allowed (immutable metadata)${NORM}"
		return $FAIL
	fi

	# Repeat the test for the file mode.
	chmod 600 test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot set same mode for test-file${NORM}"
		return $FAIL
	fi

	chmod 644 test-file 2> /dev/null
	if [ $? -eq 0 ]; then
		echo "${RED}Mode change for test-file should not be allowed (immutable metadata)${NORM}"
		return $FAIL
	fi

	if [ -f /usr/bin/chcon ]; then
		# Repeat the test for the SELinux label.
		label=$(ls -lZ test-file | awk '{print $5}')

		chcon $label test-file
		if [ $? -ne 0 ]; then
			echo "${RED}Cannot set same security.selinux for test-file${NORM}"
			return $FAIL
		fi

		chcon -t null_device_t test-file 2> /dev/null
		if [ $? -eq 0 ]; then
			echo "${RED}security.selinux change for test file should not be allowed (immutable metadata)${NORM}"
			return $FAIL
		fi
	fi

	# Repeat the test for the IMA signature.
	ima_xattr=$(get_xattr security.ima test-file)
	if [ -z "$ima_xattr" ]; then
		echo "${RED}security.ima not found${NORM}"
		return $FAIL
	fi

	setfattr -n security.ima -v 0x$ima_xattr test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot set same security.ima for test-file${NORM}"
		return $FAIL
	fi

	last_char=${ima_xattr: -1}
	((last_char += 1))
	((last_char %= 10))
	ima_xattr=${ima_xattr:0:-1}$last_char

	setfattr -n security.ima -v 0x$ima_xattr test-file 2> /dev/null
	if [ $? -eq 0 ]; then
		echo "${RED}Change of security.ima for test-file should not be allowed (immutable metadata)${NORM}"
		return $FAIL
	fi

	# Repeat the test for ACLs.
	setfacl -m u::rw test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot preserve security.posix_acl for test-file${NORM}"
		return $FAIL
	fi

	setfacl -m u::rwx test-file 2> /dev/null
	if [ $? -eq 0 ]; then
		echo "${RED}Change of security.posix_acl for test-file should not be allowed (immutable metadata)${NORM}"
		return $FAIL
	fi

	return $OK
}

cleanup_metadata_change() {
	rm -f test-file
}

# Requires:
# - evm: Refuse EVM_ALLOW_METADATA_WRITES only if an HMAC key is loaded
check_enable_metadata_modification() {
	echo "Test: ${FUNCNAME[0]}"

	if [ $evm_value -ne $EVM_INIT_X509 ]; then
		echo "${CYAN}EVM mode $EVM_INIT_X509 required${NORM}"
		return $SKIP
	fi

	if [ "$TST_EVM_CHANGE_MODE" -ne 1 ]; then
		echo "${CYAN}EVM mode change not allowed, set TST_EVM_CHANGE_MODE to 1${NORM}"
		return $SKIP
	fi

	echo $EVM_ALLOW_METADATA_WRITES > /sys/kernel/security/evm
	evm_value=$(cat /sys/kernel/security/evm)
	if [ $evm_value -ne $(($EVM_INIT_X509 | $EVM_ALLOW_METADATA_WRITES)) ]; then
		echo "${RED}EVM initialization value not correctly set${NORM}"
		return $FAIL
	fi

	return $OK
}

# Requires:
# - evm: Introduce evm_status_revalidate()
# - evm: Execute evm_inode_init_security() only when an HMAC key is loaded
check_evm_revalidate() {
	echo "Test: ${FUNCNAME[0]}"

	if [ $evm_value -ne $(($EVM_INIT_X509 | $EVM_ALLOW_METADATA_WRITES)) ]; then
		echo "${CYAN}EVM mode $(($EVM_INIT_X509 | $EVM_ALLOW_METADATA_WRITES)) required${NORM}"
		return $SKIP
	fi

	echo "test" > test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot write test-file${NORM}"
		return $FAIL
	fi

	chmod 600 test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot change mode of test-file${NORM}"
		return $FAIL
	fi

	# We need to defer setting the correct owner, as there could be
	# already an IMA policy rule preventing evmctl from reading the
	# file to calculate the digest.
	evmctl sign -o -a sha256 --imahash --uid $APPRAISE_FOWNER --key $key_path test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot sign test-file${NORM}"
		return $FAIL
	fi

	chown $APPRAISE_FOWNER test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot change owner of test-file${NORM}"
		return $FAIL
	fi

	check_load_ima_rule "$APPRAISE_RULE"
	result=$?
	if [ $result -ne $OK ]; then
		return $result
	fi

	# Read the file so that IMA would not re-appraise it next time.
	cat test-file &> /dev/null
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot read test-file${NORM}"
		return $FAIL
	fi

	# After enabling metadata modification, operations should succeed even
	# if the file has a portable signature. However, the previously cached
	# appraisal status should be invalidated.
	chmod 644 test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot change mode of test-file${NORM}"
		return $FAIL
	fi

	# Here check if IMA re-appraised the file. The read should fail
	# since now file metadata is invalid.
	cat test-file &> /dev/null
	if [ $? -eq 0 ]; then
		echo "${RED}Read of test-file should not succeed (invalid mode)${NORM}"
		return $FAIL
	fi

	# Restore metadata back to the original value.
	chmod 600 test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot restore original mode of test-file${NORM}"
		return $FAIL
	fi

	# Ensure that now IMA appraisal succeeds.
	cat test-file > /dev/null
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot read test-file after restoring correct mode${NORM}"
		return $FAIL
	fi

	if [ -f /usr/bin/chcon ]; then
		# Repeat the test for the SELinux label.
		label=$(ls -lZ test-file | awk '{print $5}')

		chcon -t null_device_t test-file
		if [ $? -ne 0 ]; then
			echo "${RED}Cannot change security.selinux of test-file${NORM}"
			return $FAIL
		fi

		cat test-file &> /dev/null
		if [ $? -eq 0 ]; then
			echo "${RED}Read of test-file should not succeed (invalid security.selinux)${NORM}"
			return $FAIL
		fi

		chcon $label test-file
		if [ $? -ne 0 ]; then
			echo "${RED}Cannot restore original security.selinux of test-file${NORM}"
			return $FAIL
		fi

		cat test-file > /dev/null
		if [ $? -ne 0 ]; then
			echo "${RED}Cannot read test-file after restoring correct security.selinux${NORM}"
			return $FAIL
		fi
	fi

	# Repeat the test for the IMA signature.
	ima_xattr=$(get_xattr security.ima test-file)
	if [ -z "$ima_xattr" ]; then
		echo "${RED}security.ima not found${NORM}"
		return $FAIL
	fi

	last_char=${ima_xattr: -1}
	((last_char += 1))
	((last_char %= 10))
	ima_xattr_new=${ima_xattr:0:-1}$last_char

	setfattr -n security.ima -v 0x$ima_xattr_new test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot set security.ima of test-file${NORM}"
		return $FAIL
	fi

	cat test-file &> /dev/null
	if [ $? -eq 0 ]; then
		echo "${RED}Read of test-file should not succeed (invalid security.ima)${NORM}"
		return $FAIL
	fi

	setfattr -n security.ima -v 0x$ima_xattr test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot restore original security.ima of test-file${NORM}"
		return $FAIL
	fi

	cat test-file > /dev/null
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot read test-file after restoring correct security.ima${NORM}"
		return $FAIL
	fi

	# Repeat the test for ACLs.
	setfacl -m u::rwx test-file 2> /dev/null
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot change security.posix_acl${NORM}"
		return $FAIL
	fi

	cat test-file &> /dev/null
	if [ $? -eq 0 ]; then
		echo "${RED}Read of test-file should not succeed (invalid security.posix_acl)${NORM}"
		return $FAIL
	fi

	setfacl -m u::rw test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot restore original security.posix_acl for test-file${NORM}"
		return $FAIL
	fi

	cat test-file > /dev/null
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot read test-file after restoring correct security.posix_acl${NORM}"
		return $FAIL
	fi

	return $OK
}

cleanup_evm_revalidate() {
	rm -f test-file
}

# Requires:
# evm: Ignore INTEGRITY_NOLABEL if no HMAC key is loaded
# evm: Introduce evm_status_revalidate()
# ima: Allow imasig requirement to be satisfied by EVM portable signatures
# evm: Execute evm_inode_init_security() only when an HMAC key is loaded
check_evm_portable_sig_ima_appraisal() {
	echo "Test: ${FUNCNAME[0]}"

	if [ $evm_value -ne $(($EVM_INIT_X509 | $EVM_ALLOW_METADATA_WRITES)) ]; then
		echo "${CYAN}EVM mode $(($EVM_INIT_X509 | $EVM_ALLOW_METADATA_WRITES)) required${NORM}"
		return $SKIP
	fi

	echo "test" > test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot write test-file${NORM}"
		return $FAIL
	fi

	chmod 600 test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot change mode of test-file${NORM}"
		return $FAIL
	fi

	# We need to defer setting the correct owner, as there could be
	# already an IMA policy rule preventing evmctl from reading the
	# file to calculate the digest.
	evmctl sign -o -a sha256 --imahash --uid $APPRAISE_DIGSIG_FOWNER --key $key_path test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot sign test-file${NORM}"
		return $FAIL
	fi

	chown $APPRAISE_DIGSIG_FOWNER test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot change owner of test-file${NORM}"
		return $FAIL
	fi

	check_load_ima_rule "$APPRAISE_DIGSIG_RULE"
	result=$?
	if [ $result -ne $OK ]; then
		return $result
	fi

	# Ensure that a file with a portable signature satisfies the
	# appraise_type=imasig requirement specified in the IMA policy.
	cat test-file > /dev/null
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot read test-file${NORM}"
		return $FAIL
	fi

	# Even files with a portable signature should be considered as
	# immutable by IMA. Write should fail.
	echo "test" 2> /dev/null >> test-file
	if [ $? -eq 0 ]; then
		echo "${RED}Write to test-file should not succeed (immutable metadata)${NORM}"
		return $FAIL
	fi

	tar --xattrs-include=* -cf test-archive.tar test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot create archive with xattrs${NORM}"
		return $FAIL
	fi

	mkdir out

	# Appraisal of the new file, extracted by tar, should succeed
	# not only if the new file has an IMA signature but also if
	# it has a portable signature.
	tar --xattrs-include=* -xf test-archive.tar -C out
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot extract archive with xattrs${NORM}"
		return $FAIL
	fi

	# Check if xattrs have been correctly set.
	xattr_orig=$(get_xattr security.selinux test-file)
	xattr=$(get_xattr security.selinux out/test-file)
	if [ "$xattr" != "$xattr_orig" ]; then
		echo "${RED}security.selinux mismatch between original and extracted file${NORM}"
		return $FAIL
	fi

	xattr_orig=$(get_xattr security.ima test-file)
	xattr=$(get_xattr security.ima out/test-file)
	if [ "$xattr" != "$xattr_orig" ]; then
		echo "${RED}security.ima mismatch between original and extracted file${NORM}"
		return $FAIL
	fi

	xattr_orig=$(get_xattr security.evm test-file)
	xattr=$(get_xattr security.evm out/test-file)
	if [ "$xattr" != "$xattr_orig" ]; then
		echo "${RED}security.evm mismatch between original and extracted file${NORM}"
		return $FAIL
	fi

	# Check if attrs have been correctly set.
	owner=$(stat -c "%u" out/test-file)
	if [ "$owner" != "$APPRAISE_DIGSIG_FOWNER" ]; then
		echo "${RED}owner mismatch between original and extracted file${NORM}"
		return $FAIL
	fi

	mode=$(stat -c "%a" out/test-file)
	if [ "$mode" != "600" ]; then
		echo "${RED}mode mismatch between original and extracted file${NORM}"
		return $FAIL
	fi

	return $OK
}

cleanup_evm_portable_sig_ima_appraisal() {
	rm -f test-file test-archive.tar
	rm -Rf out
}

# Requires:
# ima: Introduce template field evmsig and write to field sig as fallback
# evm: Execute evm_inode_init_security() only when an HMAC key is loaded
check_evm_portable_sig_ima_measurement_list() {
	echo "Test: ${FUNCNAME[0]}"

	echo "test" > test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot write test-file${NORM}"
		return $FAIL
	fi

	chown $MEASURE_FOWNER test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot change owner of test-file${NORM}"
		return $FAIL
	fi

	evmctl sign -o -a sha256 --imahash --key $key_path test-file
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot sign test-file${NORM}"
		return $FAIL
	fi

	check_load_ima_rule "$MEASURE_RULE"
	result=$?
	if [ $result -ne $OK ]; then
		return $result
	fi

	# Read the file to add it to the measurement list.
	cat test-file > /dev/null
	if [ $? -ne 0 ]; then
		echo "${RED}Cannot read test-file${NORM}"
		return $FAIL
	fi

	evm_sig_fs=$(get_xattr security.evm test-file)
	if [ -z "$evm_sig_fs" ]; then
		echo "${RED}security.evm not found${NORM}"
		return $FAIL
	fi

	# Search security.evm in the measurement list.
	evm_sig_list=$(cat /sys/kernel/security/ima/ascii_runtime_measurements | awk '$6 == "'$evm_sig_fs'"')
	if [ -z "$evm_sig_list" ]; then
		echo "${RED}security.evm mismatch (xattr != measurement list)${NORM}"
		return $FAIL
	fi

	return $OK
}

cleanup_evm_portable_sig_ima_measurement_list() {
	rm -f test-file
}

if [ $(whoami) != "root" ]; then
	echo "${CYAN}This script must be executed as root${NORM}"
	exit $SKIP
fi

if [ ! -f "/lib/modules/$(uname -r)/source/certs/signing_key.pem" ]; then
	echo "${CYAN}Kernel signing key not found in /lib/modules/$(uname -r)/source/certs/signing_key.pem${NORM}"
	exit $SKIP
fi

if [ ! -f "/sys/kernel/security/evm" ]; then
	echo "${CYAN}EVM support in the kernel disabled${NORM}"
	exit $SKIP
fi

evm_value=$(cat /sys/kernel/security/evm)

ima_keyring=".ima"
evm_keyring=".evm"

if [ -z "$ima_keyring" ] || [ -z "$evm_keyring" ]; then
	echo "${RED}IMA/EVM keyrings not found${NORM}"
	exit $FAIL
fi

key_path="$PWD/signing_key.pem"
key_path_der=${key_path%.pem}.der

openssl x509 -in $key_path --out $key_path_der -outform der

ima_keyring_num_keys=$(cat /proc/keys | awk '$9 == "'$ima_keyring:'" {print $10}')

if [ "$ima_keyring_num_keys" = "empty" ]; then
	cat $key_path_der | keyctl padd asymmetric pubkey %keyring:$ima_keyring &> /dev/null
fi

dd if=/dev/zero of=test.img bs=1M count=10 &> /dev/null
if [ $? -ne 0 ]; then
	echo "${RED}Cannot create test image${NORM}"
	exit $FAIL
fi

dev=$(losetup -f test.img --show)
if [ -z "$dev" ]; then
	echo "${RED}Cannot create loop device${NORM}"
	exit $FAIL
fi

mkfs.ext4 -U $IMA_UUID $dev &> /dev/null
mount -o i_version $dev /mnt
if [ $? -ne 0 ]; then
	echo "${RED}Cannot mount loop device${NORM}"
	exit $FAIL
fi

loop_mounted=1
pushd /mnt > /dev/null

expect_pass check_ima_sig_appraisal
cleanup_ima_sig_appraisal
expect_pass check_ima_sig_ima_measurement_list
cleanup_ima_sig_ima_measurement_list

if [ $(($evm_value & $EVM_INIT_X509)) -ne $EVM_INIT_X509 ] && [ "$TST_EVM_CHANGE_MODE" -eq 1 ]; then
	cat $key_path_der | keyctl padd asymmetric pubkey %keyring:$evm_keyring &> /dev/null
	if [ $? -ne 0 ]; then
		echo "${RED}Public key cannot be added to the EVM keyring${NORM}"
		exit $FAIL
	fi

	echo $EVM_INIT_X509 > /sys/kernel/security/evm
	evm_value=$(cat /sys/kernel/security/evm)
fi

expect_pass check_create_file
cleanup_create_file
expect_pass check_cp_preserve_xattrs
cleanup_cp_preserve_xattrs
expect_pass check_tar_extract_xattrs_different_owner
cleanup_tar_extract_xattrs_different_owner
expect_pass check_tar_extract_xattrs_same_owner
cleanup_tar_extract_xattrs_same_owner
expect_pass check_metadata_change
cleanup_metadata_change
expect_pass check_enable_metadata_modification
expect_pass check_evm_revalidate
cleanup_evm_revalidate
expect_pass check_evm_portable_sig_ima_appraisal
cleanup_evm_portable_sig_ima_appraisal
expect_pass check_evm_portable_sig_ima_measurement_list
cleanup_evm_portable_sig_ima_measurement_list
